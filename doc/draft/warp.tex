\section{Warping}

The key idea of this paper is that when transactions run
awry into an inconsistent state, rather than aborting them and
starting again from the beginning, it may be possible to
\emph{correct} the shared/local state directly by directly
modifying the state. Thus, the program continues as if it had not
gone down the bad path to the inconsistent state.

We now formalize a simple version where, from an inconsistent state,
the system warps to a state that was reachable in a serial
interleaving. We later show this can be easily generalized to allow
warping to more subtle states (such as those described by the
Push/Pull model~\cite{}). These \emph{super}-serial (yet still
serializable) allow for more possible destinations, making it more
likely that a destination will be available when an inconsistent state
is reached.


\paragraph{Unconstrained transition system.}

We begin with a generic transition system $\xrightarrow{u}$ in which threads may
interleave their effects however they please:
%{\bf Unconstrained Machine Rules} $\xrightarrow{u}$
$$
\infer[\text{\sc UFin}]{ 
  \As_1 \cdot (c,\sigma) \cdot \As_2, G  \xrightarrow{u}
  \As_1 \cdot \As_2, G 
}{
  \nothing{c}
}
$$
$$
\infer[\text{\sc UFork}]{ 
  \As_1 \cdot (c,\sigma) \cdot \As_2, G  \xrightarrow{u}
  \As_1 \cdot (c_2,\sigma) \cdot (c',\sigma) \cdot \As_2, G 
}{
  \tstep{c_1}{\fork{c}}{c_2}
}
$$
$$
\infer[\text{\sc ULocal}]{ 
  \As_1 \cdot (c,\sigma) \cdot \As_2, G  \xrightarrow{u}
  \As_1 \cdot (c',\sigma') \cdot \As_2, G 
}{
  \tstep{c}{\local{R}}{c'} & R\ \sigma\ \sigma'
}
$$
$$
\infer[\text{\sc UTxn}]{ 
  \As_1 \cdot (\tx{c_1},\sigma) \cdot \As_2, G  \xrightarrow{u}
  \As_1 \cdot (\tx{c_2},\sigma') \cdot \As_2, G\cdot \langle m,\sigma,\sigma' \rangle
}{
  \step{c_1}{m}{c_2} &
  G \allows \langle m,\sigma,\sigma' \rangle
}
$$
The semantics is a relation
$\xrightarrow{u}$ over pairs consisting of a list of concurrent
threads $\As$ and a shared state $\OPL$. 
A single thread $(c,\sigma)\in\As$ is a code $c$ and local state $\sigma$. 

The unconstrained machine can take a {\sc UFin} step when there is a thread
$(c,\sigma)$ that can complete, \ie~$\nothing{c}$.
%
The {\sc UFork} rule allows a new thread
$(c',\sigma)$ to be forked from thread $(c,\sigma)$.
%
The {\sc ULocal} rule involves manipulating the thread-local state
$\sigma$ to $\sigma'$.
%
Finally, the {\sc UTxn} rule allows a thread executing transaction
code $\tx{c_1}$ to take a single step to $c_2$, applying the effects
of $m$ directly to the shared log $G$.

%\subsection{Serializable Transition Systems}

\paragraph{Corrective Warping and Committing.}
A simple version of warping (which we have implemented in
Section~\ref{sec:impl}) builds on an unconstrained transition system
$\xrightarrow{u}$ by adding a special {\sc WarpCmt} rule. This rule
attempts to perform a warp---
replacing the current state with state that would have been reached in
an atomic interleaving and then committing---or else, aborts. This is
already more expressive than all existing notions of transactions
which, in the face of an inconsistent state perform a (potentially
partial) abort.

\red{add the fact that each thread remembers the $\Ts,G$ where they began}

$$
\infer[\text{\sc WarpCmt}]{ 
  \As_1 \cdot ((\tx{c_1},\red{c_2}),\sigma) \cdot \As_2, G  \xrightarrow{u}
  \As'_1 \cdot (c'_2,\sigma') \cdot \As'_2, G'
}{
  \nothing{c_1} &
   \text{\red{Warp}}(  \As_1 \cdot (c_2,\sigma) \cdot \As_2, G,
  \As'_1 \cdot (c'_2,\sigma') \cdot \As'_2, G')
}
$$


\red{how to jump to an atomic state? you haven't committed yet.}

\red{reference state issue.}

\red{conditions on warping - consistency.}

\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip
\bigskip

\red{\bf ALL THIS MAY BE DEAD}

\begin{definition}[Serializable transition system]
For all $\Ts,\OPL$, we say that a fragment 
$\xrightarrow{ser}$ of transition system $\xrightarrow{}$ is
serializable provided that 
$\xrightarrow{ser}$ simulates $\xrightarrow{a}$.
\end{definition}

\red{explain what simulates means}

As previously shown, the Push/Pull transition system is such a
serializable transition system~\cite{PMPY}.

\begin{definition}[Good configuration]
A configuration $\Ts,\OPL$ is \emph{good} provided that it is reachable in
some serializable transition system $\xrightarrow{ser}$
\end{definition}


\newcommand\rc[2]{\textsf{rc}(#1,#2)}
\begin{definition}[Reference configuration]
For a given transition system with initial configuration $\Ts_0,G_0$,
we define a \emph{reference configuration}, denoted
$\rc{\Ts,G}$ to be given by the fixpoint
$$
\infer{\rc{\Ts_0}{G}}{}
\qquad
\infer{\rc{\Ts'}{G''}}{
   \rc{\Ts}{G}
&  \Ts,G \xrightarrow{ser}^{*} \Ts',G'
&  G'' \opeq G'
}
$$
\end{definition}

\paragraph{Warping correctness.} The goal of warping is simple. For a reference
configuration $\Ts_0,G_0$, when we have 
$\Ts_0,G_0 \xrightarrow{u}^{*} \Ts,G$, we wish to
\[ \begin{array}{rl}
   \text{Find } \Ts',G'' \text{ such that}&
      \Ts_0,G_0 \xrightarrow{s} \Ts',G'\\
  \text{and}&G' \opeq G''
\end{array} \]

\paragraph{Warping utility.}
In particular, we would like to find a $\Ts',G''$ that can be 
\emph{easily computed} from $\Ts,G$.



\section{Static Computation of Warp Destinations}

\paragraph{Abstract state.}
Let $\hat{\Sigma} = \Ts \times G$, denoted $\hat{\sigma} = (\Ts,G)$.

\newcommand\ts{\bar{t}}

\paragraph{Concrete state.}
Let $\Sigma = \gamma(\Ts \times G)$ be the concrete states, denoted $\sigma = (\ts,g)$.

\newcommand\Pietrot{{\cal P}ietro}

Discover a $\Pietrot : \hat{\Sigma} \rightarrow \hat{\Sigma}
\rightarrow \wp({\hat{\Sigma}})$, representing the current abstract
state, the reference abstract state, and a set of possible destination
abstract states.


%\newcommand\llangle{\langle\!\langle}
%\newcommand\rrangle{\rangle\!\rangle}

\section{Dynamic Warping}

\newcommand\Pengt{{\cal P}eng}
Given $\Pietrot$, the runtime system implements a function
denoted $\Pengt : \sigma \rightarrow \hat{\sigma} \rightarrow \hat{\sigma} \rightarrow \sigma$. 


Runtime tracks the current concrete state $\sigma$,
current \emph{abstract state} $\hat{\sigma}$ and the last
\emph{abstract reference state} $\hat{\sigma}_0$. Thus, we denote the runtime
configuration as
$$
    c =  \llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle 
\;\;\;\text{ or, expanding }
    \llangle (\ts,g),(\Ts,G),(\Ts_0,G_0) \rrangle 
$$
That is, threads are in state $\ts$, shared state $g$, tracked abstract state
$(\Ts,G)$ and tracked abstract reference state $(\Ts_0,G_0)$.

There are then the following rules for steps in the runtime system:

$$
\infer=[\text{\bf Diverge}]{
   \llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle 
  \hookrightarrow^{*}
   \llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle 
}{ ... }
$$


$$
\infer=[\text{\bf Warp}]{
  \llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
  \hookrightarrow
  \llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle
}{
    \hat{\sigma}' \in \Pietrot(\hat{\sigma}_0,\red{\hat{\sigma}})
  & \sigma' = \Pengt(\sigma,\hat{\sigma},\hat{\sigma}')
}
$$

$$
\infer=[\text{\bf Commit}]{
  \llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
  \hookrightarrow
  \llangle \sigma',\hat{\sigma}',\hat{\sigma}' \rrangle
}{ ... }
$$

$$
\infer=[\text{\bf Step}]{
  \llangle \sigma,\hat{\sigma},\hat{\sigma}_0 \rrangle
  \hookrightarrow
  \llangle \sigma',\hat{\sigma}',\hat{\sigma}_0 \rrangle
}{
\red{fix}
  g \in \gamma(G)
& \Ts,G \xrightarrow{P\! P} \Ts',G'
& g' \in \gamma(G')}
$$

$\Pietrot$ ensures that $\hat{\sigma}'$ is reachable from $\hat{\sigma}_0$.

$\Pengt$ ensures that $\sigma\in\gamma{\hat{\sigma}}$
and that you awlays warp before you commit (or you always eventually
warp)




\vfill
\pagebreak

\bigskip 
\bigskip 
\bigskip 

\red{THIS STUFF MIGHT BE DEAD}

PMPY works because it records old states, so you can jump backwards
and then roll forwards.


Formally, a ``warp'' from a configuration $\Ts,G$ to another
configuration $\hat{\Ts},\hat{G}$ can be thought of two steps:
\begin{enumerate}
\item Taking some $n$ steps to another warp configuration:
  $\Ts,G \xrightarrow{}^{*} \Ts',G'$
\item Swapping the shared log $G'$ with observationally equivalent
  $\hat{G}$. That is,  $\hat{G} \opeq G'$
\end{enumerate}

% $$
% \infer[\text{\sc warp}]{ \Ts, G \xrightarrow{\textsf{warp}} \hat{\Ts}, \hat{G} }
% {
%   \begin{array}{lll}    
%     \text{\underline{Local crit.}} &: \Ts,G \xrightarrow{}^{*} \Ts',G'\\
%     \text{\underline{Global crit.}} &: G' \opeq \hat{G} & \text{(implies \allowedt)}\\
%   \end{array}
% }
% $$

%    \forall `G.\ `G \text{ prefix of } G.\\
%    \text{\underline{Local crit.}} &: \forall \{\hat{c},\hat{\sigma},\hat{L}\} \in \hat{\Ts}.\  \lfloor  \hat{G} \rfloor_{\hat{t}} \sim L


%    \exists \hat{\OPL} = \numOP{1} \cdots \numOP{n}.\\
%\allowed{\hat{\OPL}} \\

In practice, there are many warp configurations that can be calculated
conveniently. For one, uncommitted transactions can rollback (dropping
their effects) and then some number of (intereleaved) steps can be taken.
%
It is often convenient to think of a \emph{reference point}, which is
a previously reached configuration $\Ts_0,G_0$ from which one might
compute subsequently reachable warp points $\hat{\Ts},\hat{\OPL}$.


%\item jump each thread $\CSL\in \Ts$ to $\CpSpLp\in\hat{\Ts}$ such that:\\
%    $c' = c$ (could relax this in the future)\\
    
\begin{theorem}[Serializability]
Corollary to the serializability of the Push/Pull model~\cite{pmpy}.
\end{theorem}


\paragraph{Discussion}

This section carves out a large space of possibilities for where one
might warp to. Some things to consider:

\begin{itemize}
\item Pessimistic/Optimistic destinations 
  (our implementation does Pessimistic)
\item Serial-vs-Serializable destinations
  (our implementation does Serial).\\
  For serializabile, the criteria of {\sc push} and {\sc pull} give
  sufficient conditions in terms of left/right-movers.
\end{itemize}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "paper"
%%% End: 
